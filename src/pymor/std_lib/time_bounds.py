import numpy as np
import xarray as xr

from ..core.logging import logger
from ..core.rule import Rule
from .dataset_helpers import get_time_label


def time_bounds(ds: xr.Dataset, rule: Rule) -> xr.Dataset:
    """
    Appends time bounds to data file if necessary coordinate dimensions exits in data file.
    Renames dimensions in data file to match the dimension name in time bounds file if necessary.

    Parameters
    ----------
    ds : xr.Dataset
        The input dataset.
    rule: Rule object containing time bounds file attribute

    Returns
    -------
    xr.Dataset
        The output dataset with the time bounds information.
    """
    # Get dataset name for logging
    dataset_name = ds.attrs.get("name", "unnamed_dataset")

    # Log header with markdown style
    logger.info(f"[Time bounds] {dataset_name}")
    logger.info(f"  → is dataset:   {'✅' if isinstance(ds, xr.Dataset) else '❌'}")

    # Check if input is a dataset
    if not isinstance(ds, xr.Dataset):
        logger.error("  ❌ The input is not a dataset.")
        raise ValueError("The input is not a dataset.")

    # Get time label and check if it exists
    time_label = get_time_label(ds)
    if time_label is None:
        logger.error("  ❌ The dataset does not contain a valid time coordinate.")
        raise ValueError("The dataset does not contain a valid time coordinate.")

    bounds_dim_label = "bnds"
    time_bounds_label = f"{time_label}_{bounds_dim_label}"

    # Log time and bounds info
    logger.info(f"  → time label  : {time_label}")
    logger.info(f"  → bounds label: {bounds_dim_label}")

    # Check if time bounds already exist
    has_time_bounds = time_bounds_label in ds.variables
    logger.info(f"  → has time bounds: {'✅' if has_time_bounds else '❌'}")

    if has_time_bounds:
        logger.info(f"  → using existing bounds: {time_bounds_label}")
        return ds

    # Create time bounds if they don't exist
    time_var = ds[time_label]
    time_values = time_var.values

    # Check if we have enough time points to create bounds
    if len(time_values) < 2:
        error_msg = "Cannot create time bounds: need at least 2 time points"
        logger.error(f"  ❌ {error_msg}")
        raise ValueError(error_msg)

    # Log time values info
    logger.info(
        f"  → time values  : {len(time_values)} points from {time_values[0]} to {time_values[-1]}"
    )

    # Calculate time difference and extend the time range
    # TODO: this is rather crude way to get the frequency.
    #       use infer_frequency from ..core.infer_freq once the PR is approved.
    time_diff = np.median(np.diff(time_values))
    time_values_full_interval = np.append(time_values, [time_values[-1] + time_diff])
    logger.info(f"  → time step    : {time_diff}")

    # Create bounds array in format [(t1, t2), (t2, t3), ...]
    bounds_data = np.column_stack(
        [time_values_full_interval[:-1], time_values_full_interval[1:]]
    )

    # Create the bounds DataArray with the correct dimensions
    bounds = xr.DataArray(
        data=bounds_data,
        dims=(time_label, bounds_dim_label),
        coords={time_label: time_values, bounds_dim_label: [0, 1]},
        attrs={
            "long_name": f"time bounds for {time_label}",
            "comment": f"Generated by pymorize: bounds between consecutive {time_label} values",
        },
    )

    # Add bounds to dataset as a coordinate variable
    ds = ds.assign_coords({time_bounds_label: bounds})

    # Add bounds attribute to time variable
    if "bounds" not in time_var.attrs:
        ds[time_label].attrs["bounds"] = time_bounds_label

    # Log success message with bounds info
    logger.info(f"  → set time bounds: {time_bounds_label}{bounds.shape}")
    logger.info(
        f"  → bounds range   : {bounds.values[0][0]} to {bounds.values[-1][-1]}"
    )
    logger.info("-" * 50)
    return ds
